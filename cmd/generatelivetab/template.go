// Copyright 2021 Hans-Werner Heinzen. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

package main

const tmpl = `// Copyright {{.Copyright}}. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// THIS FILE HAS BEEN GENERATED BY {{.Generator}} using {{.Input}}.
// ON {{.Generated}}. DO NOT EDIT.
// MANUAL CHANGES WILL DISAPPEAR AFTER NEXT RUN OF {{.Generator}}.

/*
 {{.File}} provides declarations and access functions for the {{.DbName}} table.
*/

package {{.Package}}

import (
	"database/sql"
	"fmt"

	"github.com/hwheinzen/livedb"

	. "github.com/hwheinzen/stringl10n/mistake"
)

const {{.LcAcronym}}Tab = "{{.DbName}}"

var {{.LcAcronym}}Atts = []string{ // specific fields for {{.LcAcronym}}Tab {{range .Atts}}
	"{{.DbName}}",{{end}}
}

var {{.LcAcronym}}Defs = []string{ {{range .Atts}}
	"{{.DbName}} {{.CreateClause}}",{{end}}
}

// {{.LcAcronym}} enth√§lt alle spezifischen Attribute von {{.DbName}}.
type {{.LcAcronym}} struct { {{range .Atts}}
	{{.Name}} {{if .IsNumType}}int{{/*
		*/}}{{else}}string{{end}}{{end}}
}

// {{.LcName}} contains all attributes of table {{.DbName}}.
type {{.LcName}} struct {
	livedb.Std // embedded
	{{.LcAcronym}}         // embedded
}

func {{.LcAcronym}}Scan(rows *sql.Rows) (livedb.Record, error) {
	fnc := "{{.LcAcronym}}Scan"

	std := livedb.Std{}
	nullStr1 := sql.NullString{} // Until
	nullStr2 := sql.NullString{} // Ended
	nullStr3 := sql.NullString{} // EndedBy

	x := {{.LcAcronym}}{}
	{{range $i, $att := .Atts}}
	nullVar{{$i}} := sql.Null{{if $att.IsNumType}}Int64{{else}}String{{end}}{}{{end}}

	err := rows.Scan(
		&(std.ID), &(std.Begin), &(nullStr1),
		&(std.Pkey),
		&(std.Created), &(std.CreatedBy),
		&(nullStr2), &(nullStr3),{{range $i, $p := .Atts}}
		&(nullVar{{$i}}),{{end}}
	)
	if err != nil {
		e := Err{Fix: "{{.UCPackage}}:error scanning row"}
		return livedb.Record{}, fmt.Errorf(fnc+":%w:"+err.Error(), e)
	}

	if nullStr1.Valid {
		std.Until = nullStr1.String
	}
	if nullStr2.Valid {
		std.Ended = nullStr2.String
	}
	if nullStr3.Valid {
		std.EndedBy = nullStr3.String
	} {{range $i, $att := .Atts}}
	if nullVar{{$i}}.Valid {
		x.{{$att.Name}} = {{if ne $att.Type ""}}{{$att.Type}}({{else}}{{if $att.IsNumType}}int({{end}}{{end}}{{/*
		*/}}nullVar{{$i}}.{{if $att.IsNumType}}Int64{{else}}String{{end}}{{if or (ne $att.Type "") ($att.IsNumType)}}){{end}}
	}{{end}}

	return livedb.Record{Std:std, Idv:x}, nil
}

// {{.LcAcronym}}Vals returns string representations of the fields of {{.LcName}}.
func {{.LcAcronym}}Vals(in interface{}) []string {
	//fnc := "{{.LcAcronym}}Vals"

	x := in.({{.LcAcronym}})
	_ = x // use it in case of "empty" table

	vals := make([]string, len({{.LcAcronym}}Atts)) {{$lcacr := .LcAcronym}} {{range $i, $att := .Atts}}
	vals[{{$i}}] = {{if $att.IsNumType}}fmt.Sprintf("%0.d", x.{{$att.Name}}) // "" indicates NULL{{else}}{{if ne $att.Type ""}}fmt.Sprint(x.{{$att.Name}}){{else}}x.{{$att.Name}}{{end}}{{end}}{{end}}

	return vals
}

func create{{.UcAcronym}}(tx *sql.Tx) error {
	fnc := "create{{.UcAcronym}}"

	t := livedb.Table{Name: {{.LcAcronym}}Tab, Defs: {{.LcAcronym}}Defs}
	err := t.Create(tx)
	if err != nil {
		return fmt.Errorf(fnc+":%w", err)
	}

	return nil
}

// empty{{.UcAcronym}} returns a {{.LcName}} struct with a newly reserved ID.
func empty{{.UcAcronym}}(creator string, tx *sql.Tx) (*{{.LcName}}, error) {
	fnc := "empty{{.UcAcronym}}"

	t := livedb.Table{Name: {{.LcAcronym}}Tab}
	id, err := t.NewID(creator, tx)
	if err != nil {
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	var xp = &{{.LcName}}{
		Std: livedb.Std{
			ID:   id,
			Created: creator,
		},
	}

	return xp, nil
}

// start{{.UcAcronym}} inserts the first row for a new ID,
// and returns its primary key.
func start{{.UcAcronym}}(xp *{{.LcName}}, ts, creator string, tx *sql.Tx) (int, error) {
	fnc := "start{{.UcAcronym}}"

	if xp == nil { // *{{.LcName}} needed
		err := Err{
			Fix: "{{.UCPackage}}:{{.NameTemplate}} missing",
			Var: []struct {
				Name  string
				Value interface{}
			}{
				{"Name", "{{.LcName}}"},
			},
		}
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		New:  livedb.Record{Idv: xp.{{.LcAcronym}}},
		Atts: {{.LcAcronym}}Atts,
		Vals: {{.LcAcronym}}Vals,
	}
	key, err := tab.Start(xp.ID, ts, creator, tx) // insert new row for new ID
	if err != nil {
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	return key, nil
}

// {{.LcAcronym}}Pair contains old and new {{.LcName}}.
type {{.LcAcronym}}Pair struct {
	Old {{.LcName}}
	New {{.LcName}}
}

// change{{.UcAcronym}} makes a change to {{.LcAcronym}}Tab using livedb.Change,
// and returns the primary key of the inserted row.
func change{{.UcAcronym}}(pair *{{.LcAcronym}}Pair, ts, creator string, tx *sql.Tx) (int, error) {
	fnc := "change{{.UcAcronym}}"

	if pair == nil { // *{{.LcAcronym}}Pair needed
		err := Err{
			Fix: "{{.UCPackage}}:{{.NameTemplate}} missing",
			Var: []struct {
				Name  string
				Value interface{}
			}{
				{"Name", "pair"},
			},
		}
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	old := &pair.Old
	new := &pair.New

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Old:  livedb.Record{
			Std: old.Std,
			Idv: old.{{.LcAcronym}},
		},
		New:  livedb.Record{
			Idv: new.{{.LcAcronym}},
		},
		Atts: {{.LcAcronym}}Atts,
		Vals: {{.LcAcronym}}Vals,
		Scan: {{.LcAcronym}}Scan,
	}
	key, err := tab.Change(ts, creator, tx) // regular change to row of ID
	if err != nil {
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	return key, nil
}

// terminate{{.UcAcronym}} sets the Until timestamp of the given row, eventually deletes followers,
// and returns its primary key.
func terminate{{.UcAcronym}}(xp *{{.LcName}}, ts, creator string, tx *sql.Tx) (int, error) {
	fnc := "terminate{{.UcAcronym}}"

	if xp == nil { // *{{.LcName}} needed
		err := Err{
			Fix: "{{.UCPackage}}:{{.NameTemplate}} missing",
			Var: []struct {
				Name  string
				Value interface{}
			}{
				{"Name", "{{.LcName}}"},
			},
		}
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Old:  livedb.Record{
			Std: xp.Std,
			Idv: xp.{{.LcAcronym}},
		},
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}
	key, err := tab.Terminate(ts, creator, tx) // terminate row of ID
	if err != nil {
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	return key, nil
}

// moveBegin{{.UcAcronym}} begins a given {{.LcName}} row with Begin = ts.
func moveBegin{{.UcAcronym}}(xp *{{.LcName}}, ts, creator string, tx *sql.Tx) (int, error) {
	fnc := "moveBegin{{.UcAcronym}}"

	if xp == nil { // *{{.LcName}} needed
		err := Err{
			Fix: "{{.UCPackage}}:{{.NameTemplate}} missing",
			Var: []struct {
				Name  string
				Value interface{}
			}{
				{"Name", "{{.LcName}}"},
			},
		}
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Old:  livedb.Record{
			Std: xp.Std,
			Idv: xp.{{.LcAcronym}},
		},
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}
	key, err := tab.MoveBegin(ts, creator, tx) // terminate row of ID
	if err != nil {
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	return key, nil
}

// moveUntil{{.UcAcronym}} ends a given {{.LcName}} row with Until = ts.
func moveUntil{{.UcAcronym}}(xp *{{.LcName}}, ts, creator string, tx *sql.Tx) (int, error) {
	fnc := "moveUntil{{.UcAcronym}}"

	if xp == nil { // *{{.LcName}} needed
		err := Err{
			Fix: "{{.UCPackage}}:{{.NameTemplate}} missing",
			Var: []struct {
				Name  string
				Value interface{}
			}{
				{"Name", "{{.LcName}}"},
			},
		}
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Old:  livedb.Record{
			Std: xp.Std,
			Idv: xp.{{.LcAcronym}},
		},
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}
	key, err := tab.MoveUntil(ts, creator, tx) // terminate row of ID
	if err != nil {
		return 0, fmt.Errorf(fnc+":%w", err)
	}

	return key, nil
}

func recsTo{{.UcAcronym}}(recs []livedb.Record) (xs []{{.LcName}}) {
	var x {{.LcName}}
	for _, v := range recs {
		x = {{.LcName}}{Std: v.Std, {{.LcAcronym}}: v.Idv.({{.LcAcronym}})}
		xs = append(xs, x)
	}
	return xs
}

func {{.LcAcronym}}ByKey(key int, tx *sql.Tx) ([]{{.LcName}}, error) {
	fnc := "{{.LcAcronym}}ByKey"

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}

	recs, err := tab.ByKey(key, tx)
	if err != nil {
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	return recsTo{{.UcAcronym}}(recs), nil
}

func {{.LcAcronym}}sByTs(ts string, tx *sql.Tx) ([]{{.LcName}}, error) {
	fnc := "{{.LcAcronym}}sByTs"

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}

	recs, err := tab.ByTs(ts, tx)
	if err != nil {
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	return recsTo{{.UcAcronym}}(recs), nil
}

func {{.LcAcronym}}ByIDTs(id int, ts string, tx *sql.Tx) ([]{{.LcName}}, error) {
	fnc := "{{.LcAcronym}}ByIDTs"

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}

	recs, err := tab.ByIDTs(id, ts, tx)
	if err != nil {
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	return recsTo{{.UcAcronym}}(recs), nil
}

func {{.LcAcronym}}ByIDBegin(id int, begin string, tx *sql.Tx) ([]{{.LcName}}, error) {
	fnc := "{{.LcAcronym}}ByIDBegin"

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}

	recs, err := tab.ByIDBegin(id, begin, tx)
	if err != nil {
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	return recsTo{{.UcAcronym}}(recs), nil
}

func {{.LcAcronym}}ByIDUntil(id int, until string, tx *sql.Tx) ([]{{.LcName}}, error) {
	fnc := "{{.LcAcronym}}ByIDUntil"

	tab := livedb.Table {
		Name: {{.LcAcronym}}Tab,
		Atts: {{.LcAcronym}}Atts,
		Scan: {{.LcAcronym}}Scan,
	}

	recs, err := tab.ByIDUntil(id, until, tx)
	if err != nil {
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	return recsTo{{.UcAcronym}}(recs), nil
}
{{$Name := .LcName}}{{$LcAcronym := .LcAcronym}}{{$UcAcronym := .UcAcronym}}{{range .Atts}}{{if .ReadBy}}

func {{$LcAcronym}}sBy{{.Name}}Ts({{.LcName}} {{if .IsNumType}}int{{else}}string{{end}}, ts string, tx *sql.Tx) ([]{{$Name}}, error) {
	fnc := "{{$LcAcronym}}sByIDTs"

	tab := livedb.Table {
		Name: {{$LcAcronym}}Tab,
		Atts: {{$LcAcronym}}Atts,
		Scan: {{$LcAcronym}}Scan,
	}

	nvs := []livedb.NameValue{ {Name: "{{.Name}}", Value: {{.LcName}}} }
	recs, err := tab.ByTsAndXs(ts, nvs, tx)
	if err != nil {
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	return recsTo{{$UcAcronym}}(recs), nil
}{{end}}{{end}}

// THIS FILE HAS BEEN GENERATED BY {{.Generator}} using {{.Input}}.
// ON {{.Generated}}. DO NOT EDIT.
// MANUAL CHANGES WILL DISAPPEAR AFTER NEXT RUN OF {{.Generator}}.
`
