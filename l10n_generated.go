// Copyright 2021 Hans-Werner Heinzen. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// THIS FILE HAS BEEN GENERATED BY l10n using l10n.json.
// ON 2021-08-24 10:35:06.526230056 +0200 CEST. DO NOT EDIT.
// CHANGES WILL DISAPPEAR AFTER NEXT RUN OF l10n.

/*
 l10n_generated.go contains all localized strings and
 functions for translating (L10nTranslate),
 replacing text/template variables (L10nReplace),
 and a conveniance function for localizing errors (L10nLocalizeError)
*/

package livedb

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"strings"
	"text/template"

	. "github.com/hwheinzen/stringl10n/mistake"
)

// Type l10nPair is used during string localization.
type l10nPair struct {
	Lang  string
	Value string
}

// l10nMap contains all key strings with all their translations.
var l10nMap = make(map[string][]l10nPair, 10)

// L10nTranslate returns the adequate translation of a given text
// according to the chosen language code or an error.
func L10nTranslate(key, lang string) (string, error) {
	fnc := "L10nTranslate"

	if key == "" {
		err := errors.New("L10N:key missing")
		return "", fmt.Errorf(fnc+":%w", err)
	}
	if lang == "" {
		err := errors.New("L10N:lang missing")
		return "", fmt.Errorf(fnc+":%w", err)
	}

	pairs, ok := l10nMap[key]
	if !ok {
		err := errors.New("L10N:no entry for '" + key + "'")
		return "", fmt.Errorf(fnc+":%w", err)
	}
	for _, v := range pairs {
		if len(lang) >= 5 { // assuming POSIX locales: language + country
			if v.Lang == lang[:5] {
				return v.Value, nil // found
			}
		}
	}
	for _, v := range pairs {
		if len(lang) >= 2 { // assuming POSIX locales: language only
			if v.Lang == lang[:2] {
				return v.Value, nil // found
			}
		}
	}

	err := errors.New("L10N:no " + lang + " translation for '" + key + "'")
	return "", fmt.Errorf(fnc+":%w", err)
}

// l10nVars declares all variables possibly needed for substitution.
type l10nVars struct {
	Name  string
	Nam1  string
	Nam2  string
	Date  string
	Tmsp  string
	Ref   string
	Int   int
	Int1  int
	Int2  int
	Type  string
	Table string
	Query string
}

// L10nReplace replaces text/template expressions and returns
// the changed text string. Variables in these text/template
// expressions are substituted by values or an error.
func L10nReplace(tmpl string, vars []struct {
	Name  string
	Value interface{}
}) (string, error) {
	fnc := "L10nReplace"

	if tmpl == "" {
		err := errors.New("L10N:tmpl missing")
		return "", fmt.Errorf(fnc+":%w", err)
	}

	t := template.New("t")
	_, err := t.Parse(tmpl)
	if err != nil {
		e := errors.New("L10N:error parsing template:\n'" + tmpl + "'\n")
		return "", fmt.Errorf(fnc+":%w:"+err.Error(), e)
	}

	allVars := l10nVars{}

	for _, pair := range vars {
		switch pair.Name {
		case "Name":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Name' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Name = v
		case "Nam1":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Nam1' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Nam1 = v
		case "Nam2":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Nam2' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Nam2 = v
		case "Date":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Date' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Date = v
		case "Tmsp":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Tmsp' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Tmsp = v
		case "Ref":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Ref' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Ref = v
		case "Int":
			v, ok := pair.Value.(int)
			if !ok {
				err = errors.New("L10N:variable 'Int' should have type int but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Int = v
		case "Int1":
			v, ok := pair.Value.(int)
			if !ok {
				err = errors.New("L10N:variable 'Int1' should have type int but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Int1 = v
		case "Int2":
			v, ok := pair.Value.(int)
			if !ok {
				err = errors.New("L10N:variable 'Int2' should have type int but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Int2 = v
		case "Type":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Type' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Type = v
		case "Table":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Table' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Table = v
		case "Query":
			v, ok := pair.Value.(string)
			if !ok {
				err = errors.New("L10N:variable 'Query' should have type string but has " + fmt.Sprintf("%T", pair.Value) + " in template:\n'" + tmpl + "'\n")
				return "", fmt.Errorf(fnc+":%w:", err)
			}
			allVars.Query = v
		default:
			err = errors.New("L10N:variable '" + pair.Name + "' not declared for template:\n'" + tmpl + "'\n")
			return "", fmt.Errorf(fnc+":%w", err)
		}
	}

	var b bytes.Buffer
	err = t.Execute(&b, allVars)
	if err != nil {
		e := errors.New("L10N:error executing template:\n'" + tmpl + "'\n")
		return "", fmt.Errorf(fnc+":%w:"+err.Error(), e)
	}

	return b.String(), nil
}

// L10nLocalizeError takes the innermost wrapped error of in and tries
// 1. to translate the error message and
// 2. to replace text/template expressions with variable values if available.
// It creates a new error and returns it wrapped again.
//
// If 1. fails it returns two nil errors indicating "NOTFOUND".
// If 2. fails it return nil as out and an error.
func L10nLocalizeError(in error, lang string) (out, err error) {
	fnc := "L10nLocalizeError"

	if in == nil {
		err := errors.New("L10N:in missing")
		return nil, fmt.Errorf(fnc+":%w", err)
	}
	if lang == "" {
		err := errors.New("L10N:lang missing")
		return nil, fmt.Errorf(fnc+":%w", err)
	}

	// Unwrap
	var inner, e error
	var ss []string
	for inner, e = in, errors.Unwrap(in); e != nil; inner, e = e, errors.Unwrap(e) {
		ss = append(ss, strings.Replace(inner.Error(), e.Error(), "%w", 1))
	}
	ss = append(ss, inner.Error())

	// Translate
	txt, err := L10nTranslate(inner.Error(), lang)
	if err != nil {
		return nil, nil // notfound, ignore why
	}

	// Substitute
	type varser interface {
		Vars() []struct {
			Name  string
			Value interface{}
		}
	}
	f, ok := inner.(varser)
	if ok {
		txt, err = L10nReplace(txt, f.Vars())
		if err != nil {
			return nil, fmt.Errorf(fnc+":%w", err)
		}
		out = Err{
			Fix: txt,
			Var: f.Vars(),
		}
	} else {
		out = Err{Fix: txt}
	}

	// Wrap again
	for i := len(ss) - 1; i != 0; i-- {
		out = fmt.Errorf(ss[i-1], out)
	}

	return out, nil
}

// init fills the translation map.
func init() {
	fnc := "init"

	var l10nJSON = `{
 "DUMMY": [
  {
   "Lang": "DUMMY",
   "Value": "DUMMY"
  }
 ],
 "LIVEDB:ID-table not updated": [
  {
   "Lang": "en",
   "Value": "ID-table not updated"
  },
  {
   "Lang": "de",
   "Value": "ID-Tabelle wurde nicht geändert"
  }
 ],
 "LIVEDB:access needs at least database object": [
  {
   "Lang": "en",
   "Value": "access needs at least database object"
  },
  {
   "Lang": "de",
   "Value": "Zugriff braucht zumindest ein Datenbankobjekt"
  }
 ],
 "LIVEDB:begin transaction failed": [
  {
   "Lang": "en",
   "Value": "begin transaction failed"
  },
  {
   "Lang": "de",
   "Value": "Start einer Transaktion fehlgeschlagen"
  }
 ],
 "LIVEDB:cannot change the past: {{.Name}}": [
  {
   "Lang": "en",
   "Value": "cannot change the past: {{.Name}}"
  },
  {
   "Lang": "de",
   "Value": "Änderung der Vergangenheit {{.Name}} nicht möglich"
  }
 ],
 "LIVEDB:close database failed": [
  {
   "Lang": "en",
   "Value": "close database failed"
  },
  {
   "Lang": "de",
   "Value": "Schließen der Datenbank fehlgeschlagen"
  }
 ],
 "LIVEDB:commit transaction failed": [
  {
   "Lang": "en",
   "Value": "commit transaction failed"
  },
  {
   "Lang": "de",
   "Value": "Commit einer Transaktion fehlgeschlagen"
  }
 ],
 "LIVEDB:competetively changed": [
  {
   "Lang": "en",
   "Value": "data competetively changed"
  },
  {
   "Lang": "de",
   "Value": "Daten wurden konkurrierend geändert"
  }
 ],
 "LIVEDB:competetively deleted": [
  {
   "Lang": "en",
   "Value": "data competetively deleted"
  },
  {
   "Lang": "de",
   "Value": "Daten wurden konkurrierend gelöscht"
  }
 ],
 "LIVEDB:create needs database object": [
  {
   "Lang": "en",
   "Value": "create needs database object"
  },
  {
   "Lang": "de",
   "Value": "Create Tabelle braucht ein Datenbankobjekt"
  }
 ],
 "LIVEDB:database already open": [
  {
   "Lang": "en",
   "Value": "database already open"
  },
  {
   "Lang": "de",
   "Value": "Datenbank bereits geöffnet"
  }
 ],
 "LIVEDB:error at rows.Next for query:{{.Query}}": [
  {
   "Lang": "en",
   "Value": "error at rows.Next for query:\n{{.Query}}\n"
  },
  {
   "Lang": "de",
   "Value": "Fehler bei rows.Next in Abfrage:\n{{.Query}}\n"
  }
 ],
 "LIVEDB:error at scan(rows) for query:{{.Query}}": [
  {
   "Lang": "en",
   "Value": "error at scan(rows) for query:\n{{.Query}}\n"
  },
  {
   "Lang": "de",
   "Value": "Fehler bei scan(rows) in Abfrage:\n{{.Query}}\n"
  }
 ],
 "LIVEDB:error creating index by:{{.Query}}": [
  {
   "Lang": "en",
   "Value": "error creating index by:\n{{.Query}}\n"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim create index:\n{{.Query}}\n"
  }
 ],
 "LIVEDB:error creating table by:{{.Query}}": [
  {
   "Lang": "en",
   "Value": "error creating table by:\n{{.Query}}\n"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim create table:\n{{.Query}}\n"
  }
 ],
 "LIVEDB:error executing ID-table update": [
  {
   "Lang": "en",
   "Value": "error executing ID-table update"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ausführen des update für die ID-Tabelle"
  }
 ],
 "LIVEDB:error executing delete": [
  {
   "Lang": "en",
   "Value": "error executing delete"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ausführen des delete"
  }
 ],
 "LIVEDB:error executing insert": [
  {
   "Lang": "en",
   "Value": "error executing insert"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ausführen des insert"
  }
 ],
 "LIVEDB:error executing query:{{.Query}}": [
  {
   "Lang": "en",
   "Value": "error executing query:\n{{.Query}}\n"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ausführen der Abfrage:\n{{.Query}}\n"
  }
 ],
 "LIVEDB:error executing update": [
  {
   "Lang": "en",
   "Value": "error executing update"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ausführen des update"
  }
 ],
 "LIVEDB:error getting rows affected": [
  {
   "Lang": "en",
   "Value": "error getting rows affected"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ermitteln der Anzahl betroffener Zeilen"
  }
 ],
 "LIVEDB:error inserting by:{{.Query}}": [
  {
   "Lang": "en",
   "Value": "error inserting by:\n{{.Query}}\n"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ausführen des insert:\n{{.Query}}\n"
  }
 ],
 "LIVEDB:error nexting query": [
  {
   "Lang": "en",
   "Value": "error at rows.Next"
  },
  {
   "Lang": "de",
   "Value": "Fehler bei rows.Next"
  }
 ],
 "LIVEDB:error scanning row": [
  {
   "Lang": "en",
   "Value": "error scanning row"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim scan row"
  }
 ],
 "LIVEDB:get last inserted id failed": [
  {
   "Lang": "en",
   "Value": "get last inserted id failed"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ermitteln der zuletzt eingefügte ID"
  }
 ],
 "LIVEDB:get last inserted key failed": [
  {
   "Lang": "en",
   "Value": "get last inserted key failed"
  },
  {
   "Lang": "de",
   "Value": "Fehler beim Ermitteln desr zuletzt eingefügten keys"
  }
 ],
 "LIVEDB:no transaction to commit": [
  {
   "Lang": "en",
   "Value": "no transaction to commit"
  },
  {
   "Lang": "de",
   "Value": "Commit nicht möglich - keine Transaktion aktiv"
  }
 ],
 "LIVEDB:no transaction to rollback": [
  {
   "Lang": "en",
   "Value": "no transaction to rollback"
  },
  {
   "Lang": "de",
   "Value": "Rollback nicht möglich - keine Transaktion aktiv"
  }
 ],
 "LIVEDB:not a valid timestamp": [
  {
   "Lang": "en",
   "Value": "not a valid timestamp"
  },
  {
   "Lang": "de",
   "Value": "kein gültiger Zeitstempel"
  }
 ],
 "LIVEDB:not allowed": [
  {
   "Lang": "en",
   "Value": "not allowed"
  },
  {
   "Lang": "de",
   "Value": "nicht erlaubt"
  }
 ],
 "LIVEDB:nothing deleted": [
  {
   "Lang": "en",
   "Value": "nothing deleted"
  },
  {
   "Lang": "de",
   "Value": "nichts gelöscht"
  }
 ],
 "LIVEDB:nothing updated": [
  {
   "Lang": "en",
   "Value": "nothing updated"
  },
  {
   "Lang": "de",
   "Value": "nichts geändert"
  }
 ],
 "LIVEDB:open database failed": [
  {
   "Lang": "en",
   "Value": "open database failed"
  },
  {
   "Lang": "de",
   "Value": "Öffnen der Datenbank fehlgeschlagen"
  }
 ],
 "LIVEDB:rollback transaction failed": [
  {
   "Lang": "en",
   "Value": "rollback transaction failed"
  },
  {
   "Lang": "de",
   "Value": "Rollback der Transaktion fehlgeschlagen"
  }
 ],
 "LIVEDB:scan last inserted id failed": [
  {
   "Lang": "en",
   "Value": "scan last inserted id failed"
  },
  {
   "Lang": "de",
   "Value": "Scan der letzten eingefügten ID fehlgeschlagen"
  }
 ],
 "LIVEDB:scan last inserted key failed": [
  {
   "Lang": "en",
   "Value": "scan last inserted key failed"
  },
  {
   "Lang": "de",
   "Value": "Scan des letzten eingefügten keys fehlgeschlagen"
  }
 ],
 "LIVEDB:select last inserted id failed": [
  {
   "Lang": "en",
   "Value": "select last inserted id failed"
  },
  {
   "Lang": "de",
   "Value": "Select der letzten eingefügten ID fehlgeschlagen"
  }
 ],
 "LIVEDB:select last inserted key failed": [
  {
   "Lang": "en",
   "Value": "select last inserted key failed"
  },
  {
   "Lang": "de",
   "Value": "Select des letzten eingefügten keys fehlgeschlagen"
  }
 ],
 "LIVEDB:table name missing": [
  {
   "Lang": "en",
   "Value": "table name missing"
  },
  {
   "Lang": "de",
   "Value": "Tabellenname fehlt"
  }
 ],
 "LIVEDB:table {{.Name}} exists, table {{.Nam2}} is missing": [
  {
   "Lang": "en",
   "Value": "table {{.Name}} exists, table {{.Nam2}} is missing"
  },
  {
   "Lang": "de",
   "Value": "Tabelle {{.Name}} existiert, Tabelle {{.Nam2}} fehlt"
  }
 ],
 "LIVEDB:timestamp {{.Name}} too short: {{.Tmsp}}, expected {{.Int}}+ characters": [
  {
   "Lang": "en",
   "Value": "timestamp {{.Name}} too short: {{.Tmsp}}, expected {{.Int}}+ characters"
  },
  {
   "Lang": "de",
   "Value": "Zeitstempel {{.Name}} zu kurz: {{.Tmsp}}, {{.Int}}+ Zeichen erwartet"
  }
 ],
 "LIVEDB:write access needs transaction object": [
  {
   "Lang": "en",
   "Value": "write access needs transaction object"
  },
  {
   "Lang": "de",
   "Value": "Schreibzugriff braucht eine aktive Transaktion"
  }
 ],
 "LIVEDB:{{.Name}} missing": [
  {
   "Lang": "en",
   "Value": "{{.Name}} missing"
  },
  {
   "Lang": "de",
   "Value": "{{.Name}} fehlt"
  }
 ],
 "LIVEDB:{{.Name}} missing for {{.Table}}": [
  {
   "Lang": "en",
   "Value": "{{.Name}} missing for {{.Table}}"
  },
  {
   "Lang": "de",
   "Value": "{{.Name}} fehlt für Tabelle {{.Table}}"
  }
 ]
}`

	err := json.Unmarshal([]byte(l10nJSON), &l10nMap)
	if err != nil {
		e := Err{Fix: "L10N:error unmarshaling 'l10nJSON'"}
		log.Fatalln(fnc+":%w:"+err.Error(), e)
	}
	l10nJSON = "" // no longer needed
}

// THIS FILE HAS BEEN GENERATED.
// DO NOT EDIT.
// CHANGES WILL DISAPPEAR AFTER NEXT RUN OF go generate.
